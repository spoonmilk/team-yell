from cmaes import CMA
import numpy as np
import torch as pt
import whisper
from ..models.perturbation_model import WavPerturbationModel
from ..utilities.data_access import grab_batch
from ..utilities.wer import wer

POP_SIZE = 50
BATCH_SIZE = 10
CMAES_SIGMA = 2
MODEL_TYPE = "tiny"

whisper_model = whisper.load_model(MODEL_TYPE, device="cuda")


def whisper_transcribe(audio_data: pt.Tensor) -> list[str]:
    """Transcribes all audio sequences encapsulated within an input tensor and returns whisper's transcriptions of them"""
    sized_data = whisper.pad_or_trim(audio_data)
    log_mel_data = whisper.log_mel_spectrogram(
        sized_data, n_mels=whisper_model.dims.n_mels
    ).to(whisper_model.device)
    results = list(map(lambda x: x.text, whisper.decode(whisper_model, log_mel_data, whisper.DecodingOptions())))
    return results


def build_from_params(model: WavPerturbationModel, params: np.ndarray) -> WavPerturbationModel:
    """Build a model with the same architecture as the given model, but using the given params."""
    copy = WavPerturbationModel(*model.options)
    # copy the input params (generated by CMAES) into our model
    start_ind = 0
    for param in copy.parameters():
        flat_size = param.data.shape.numel()
        to_insert = pt.tensor(params[start_ind:start_ind+flat_size])
        to_insert = pt.reshape(to_insert, param.data.shape)
        param = to_insert
        start_ind += flat_size
    return copy


def objective(model: WavPerturbationModel, batch: tuple[pt.Tensor, list[str]], params: np.ndarray) -> float:
    """Creates a perturbation model with architecture provided by the model argument and parameters by the params argument, and evalutes how good its perturbation is.

    Args:
        model (WavPerturbationModel): The base model. The actual contents of this model don't matter, we're just leeching the architecture off of it.
        batch (tuple[pt.Tensor, list[str]]): The batch of audio this model will process, alongside the labels.
        params (np.ndarray): The parameters this model will be fit with before being run.

    Returns:
        float: The average WER across the batch of data. Negated, since we want to maximize WER.
    """
    copy = build_from_params(model, params)

    # copy now has the input params generated by CMAES. Now, we want to run it to get our perturbed audio
    audio, labels = batch
    pert = copy(audio)
    # Run our perturbed audio through Whisper
    whispered_perts = whisper_transcribe(pert)
    errors = list(map(wer, labels, whispered_perts))
    return -np.mean(errors)


# run CMAES to optimize a model with the given architecture: returns an optimized model
def cmaes(model: WavPerturbationModel, generations: int):
    """Run CMAES on a perturbation model for a given number of generations: returns an optimized model."""
    # get number of total parameters - needed so we can figure out the dimensionality of our CMAES generator
    total_params = sum(p.numel() for p in model.parameters())
    # Might be nice for the initial distribution mean to start at a random spot instead of zeros, but leaving it as zeros for now.
    optimizer = CMA(mean=np.zeros(total_params), sigma=CMAES_SIGMA, population_size=POP_SIZE)
    # For each generation, we run each of our workers once, and tell the optimizer to update based on their results.
    for generation in range(generations):
        solutions = []
        # We want each worker to use the same batch: this way, each worker can actually be compared to each other. (Not sure if this is necessary, will discuss)
        generation_batch = grab_batch(BATCH_SIZE)
        # Note: we probably want to multithread this. Each worker is independent, so why not? idk multithreading in Python very well, though
        for _ in range(optimizer.population_size):
            x = optimizer.ask()
            value = objective(model, generation_batch, x)
            solutions.append((x, value))

            print(f"{generation=} {value=}")
        optimizer.tell(solutions)
    # Now our optimizer has been nice and trained, ask it for a set of params one more time and build a model with it: return that.
    return build_from_params(model, optimizer.ask())


# Demo to run CMAES
if __name__ == "__main__":
    model = WavPerturbationModel(3, 3, 3, 0.1)
    cmaes(model, 100)
